// -*- C++ -*-
//===------------------------- fstream ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_FSTREAM22
#define _LIBCPP_FSTREAM22
#include <stdio.h>


#include <ostream>
#include <istream>
#include <cstdio>
#include <cstdlib>
#include <filesystem>
#include <string.h>
#include <unistd.h>


class basic_filebuf2
    : public std::basic_streambuf<char, std::char_traits<char>>
{
public:
    typedef typename std::char_traits<char> traits_type;
    typedef typename std::char_traits<char>::int_type   int_type;
    typedef typename std::char_traits<char>::pos_type   pos_type;
    typedef typename std::char_traits<char>::off_type   off_type;
    typedef typename std::char_traits<char>::state_type state_type;

    // 27.9.1.2 Constructors/destructor:
    basic_filebuf2();
    virtual ~basic_filebuf2();

    // 27.9.1.3 Assign/swap:
    void swap(basic_filebuf2& __rhs);

    // 27.9.1.4 Members:
    bool is_open() const;

    basic_filebuf2* open(int fd);

    basic_filebuf2* close();

  protected:
    // 27.9.1.5 Overridden virtual functions:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = std::char_traits<char>::eof());
    virtual int_type overflow (int_type __c = std::char_traits<char>::eof());
    virtual std::basic_streambuf<char, std::char_traits<char>>* setbuf(char* __s, std::streamsize __n);
    virtual int sync();
    virtual void imbue(const std::locale& __loc);

private:
  char* __extbuf_;
  const char* __extbufnext_;
  const char* __extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char* __intbuf_;
  size_t __ibs_;
  int __fd_;
  const std::codecvt<char, char, state_type>* __cv_;
  state_type __st_;
  state_type __st_last_;
  std::ios_base::openmode __om_;
  std::ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;

  bool __read_mode();
  void __write_mode();
};

basic_filebuf2::basic_filebuf2()
    : __extbuf_(0),
      __extbufnext_(0),
      __extbufend_(0),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __fd_(0),
      __cv_(nullptr),
      __st_(),
      __st_last_(),
      __om_((std::ios_base::openmode)0),
      __cm_((std::ios_base::openmode)0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(false)
{
    if (std::has_facet<std::codecvt<char, char, state_type> >(this->getloc()))
    {
        __cv_ = &std::use_facet<std::codecvt<char, char, state_type> >(this->getloc());
        __always_noconv_ = __cv_->always_noconv();
    }
    setbuf(0, 4096);
}

basic_filebuf2::~basic_filebuf2()
{
#ifdef __cpp_exeptions //_LIBCPP_NO_EXCEPTIONS
    try
    {
#endif  // _LIBCPP_NO_EXCEPTIONS
        close();
#ifdef __cpp_exeptions //_LIBCPP_NO_EXCEPTIONS
    }
    catch (...)
    {
    }
#endif  // _LIBCPP_NO_EXCEPTIONS
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

inline
bool
basic_filebuf2::is_open() const
{
    return __fd_ != 0;
}

basic_filebuf2*
basic_filebuf2::open(int fd) {
  if (__fd_ != 0) {
    ::close(__fd_);
  }
  __fd_ = fd;
  return this;
}

basic_filebuf2*
basic_filebuf2::close()
{
    basic_filebuf2* __rt = 0;
    if (__fd_)
    {
        __rt = this;
        if (sync())
            __rt = 0;
        if (::close(__fd_))
            __rt = 0;
        __fd_ = 0;
        setbuf(0, 0);
    }
    return __rt;
}

typename basic_filebuf2::int_type
basic_filebuf2::underflow()
{
    if (__fd_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : std::min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char));
        if (__always_noconv_)
        {
            ssize_t __nmemb = static_cast<ssize_t>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = read(__fd_, this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = traits_type::to_int_type(*this->gptr());
            }
        }
        else
        {
            if (__extbufend_ != __extbufnext_)
                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            ssize_t __nmemb = std::min(static_cast<ssize_t>(__ibs_ - __unget_sz),
                                 static_cast<ssize_t>(__extbufend_ - __extbufnext_));
            std::codecvt_base::result __r;
            __st_last_ = __st_;
            ssize_t __nr = read(__fd_, (void*) const_cast<char *>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                if (!__cv_)
                    std::__throw_bad_cast();

                __extbufend_ = __extbufnext_ + __nr;
                char*  __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->eback() + __ibs_, __inext);
                if (__r == std::codecvt_base::noconv)
                {
                    this->setg((char*)__extbuf_, (char*)__extbuf_,
                                          (char*)const_cast<char *>(__extbufend_));
                    __c = traits_type::to_int_type(*this->gptr());
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = traits_type::to_int_type(*this->gptr());
                }
            }
        }
    }
    else
        __c = traits_type::to_int_type(*this->gptr());
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

typename basic_filebuf2::int_type
basic_filebuf2::pbackfail(int_type __c)
{
    if (__fd_ && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if ((__om_ & std::ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

typename basic_filebuf2::int_type
basic_filebuf2::overflow(int_type __c)
{
    if (__fd_ == 0)
        return traits_type::eof();
    __write_mode();
    char __1buf;
    char* __pb_save = this->pbase();
    char* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            ssize_t __nmemb = static_cast<ssize_t>(this->pptr() - this->pbase());
            if (write(__fd_, this->pbase(), __nmemb) != __nmemb) {
                return traits_type::eof();
            } 
        }
        else
        {
            char* __extbe = __extbuf_;
            std::codecvt_base::result __r;
            do
            {
                if (!__cv_)
                    std::__throw_bad_cast();

                const char* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == std::codecvt_base::noconv)
                {
                    ssize_t __nmemb = static_cast<ssize_t>(this->pptr() - this->pbase());
                    if (write(__fd_, this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == std::codecvt_base::ok || __r == std::codecvt_base::partial)
                {
                    ssize_t __nmemb = static_cast<ssize_t>(__extbe - __extbuf_);
                    if (write(__fd_, __extbuf_,  __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == std::codecvt_base::partial)
                    {
                        this->setp(const_cast<char*>(__e), this->pptr());
                        this->pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == std::codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

std::basic_streambuf<char, std::char_traits<char>>*
basic_filebuf2::setbuf(char* __s, std::streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = std::max<std::streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

int
basic_filebuf2::sync()
{
    if (__fd_ == 0)
        return 0;
    if (!__cv_) 
      std::__throw_bad_cast();

    if (__cm_ & std::ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        std::codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            ssize_t __nmemb = static_cast<ssize_t>(__extbe - __extbuf_);
            if (write(__fd_, __extbuf_,  __nmemb) != __nmemb)
                return -1;
        } while (__r == std::codecvt_base::partial);
        if (__r == std::codecvt_base::error)
            return -1;
        ::sync();
    }
    else if (__cm_ & std::ios_base::in)
    {
        off_type __c;
        state_type __state = __st_last_;
        bool __update_st = false;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    const int __off =  __cv_->length(__state, __extbuf_,
                                                     __extbufnext_,
                                                     this->gptr() - this->eback());
                    __c += __extbufnext_ - __extbuf_ - __off;
                    __update_st = true;
                }
            }
        }
        if (__update_st)
            __st_ = __state;
        __extbufnext_ = __extbufend_ = __extbuf_;
        this->setg(0, 0, 0);
        __cm_ = (std::ios_base::openmode)0;
    }
    return 0;
}

void
basic_filebuf2::imbue(const std::locale& __loc)
{
    sync();
    __cv_ = &std::use_facet<std::codecvt<char, char, state_type> >(__loc);
    bool __old_anc = __always_noconv_;
    __always_noconv_ = __cv_->always_noconv();
    if (__old_anc != __always_noconv_)
    {
        this->setg(0, 0, 0);
        this->setp(0, 0);
        // invariant, char_type is char, else we couldn't get here
        if (__always_noconv_)  // need to dump __intbuf_
        {
            if (__owns_eb_)
                delete [] __extbuf_;
            __owns_eb_ = __owns_ib_;
            __ebs_ = __ibs_;
            __extbuf_ = (char*)__intbuf_;
            __ibs_ = 0;
            __intbuf_ = 0;
            __owns_ib_ = false;
        }
        else  // need to obtain an __intbuf_.
        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_
            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)
            {
                __ibs_ = __ebs_;
                __intbuf_ = (char*)__extbuf_;
                __owns_ib_ = false;
                __extbuf_ = new char[__ebs_];
                __owns_eb_ = true;
            }
            else
            {
                __ibs_ = __ebs_;
                __intbuf_ = new char[__ibs_];
                __owns_ib_ = true;
            }
        }
    }
}

bool
basic_filebuf2::__read_mode()
{
    if (!(__cm_ & std::ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char*)__extbuf_,
                       (char*)__extbuf_ + __ebs_,
                       (char*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = std::ios_base::in;
        return true;
    }
    return false;
}

void
basic_filebuf2::__write_mode()
{
    if (!(__cm_ & std::ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char*)__extbuf_,
                           (char*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = std::ios_base::out;
    }
}

// basic_ifstream2

class basic_ifstream2
    : public std::basic_istream<char, std::char_traits<char>>
{
public:
    basic_ifstream2();

    basic_filebuf2* rdbuf() const;

    bool is_open() const;

    void open(int fd);

    void close();

private:
    basic_filebuf2 __sb_;
};

inline
basic_ifstream2::basic_ifstream2()
    : std::basic_istream<char, std::char_traits<char>>(&__sb_)
{
}

inline
basic_filebuf2*
basic_ifstream2::rdbuf() const
{
    return const_cast<basic_filebuf2*>(&__sb_);
}

inline
bool
basic_ifstream2::is_open() const
{
    return __sb_.is_open();
}


void basic_ifstream2::open(int fd) {
  if (__sb_.open(fd))
    this->clear();
  else
    this->setstate(std::ios_base::failbit);
}

inline
void
basic_ifstream2::close()
{
    if (__sb_.close() == 0)
        this->setstate(std::ios_base::failbit);
}

// basic_ofstream2

class basic_ofstream2
    : public std::basic_ostream<char, std::char_traits<char>>
{
public:
    basic_ofstream2();

    basic_filebuf2* rdbuf() const;

    bool is_open() const;

    void open(int fd);

    void close();

private:
    basic_filebuf2 __sb_;
};

inline
basic_ofstream2::basic_ofstream2()
    : std::basic_ostream<char, std::char_traits<char>>(&__sb_)
{
}


inline
basic_filebuf2*
basic_ofstream2::rdbuf() const
{
    return const_cast<basic_filebuf2*>(&__sb_);
}

inline
bool
basic_ofstream2::is_open() const
{
    return __sb_.is_open();
}

void basic_ofstream2::open(int fd) {
  if (__sb_.open(fd))
    this->clear();
  else
    this->setstate(std::ios_base::failbit);
}

inline
void
basic_ofstream2::close()
{
    if (__sb_.close() == 0)
        this->setstate(std::ios_base::failbit);
}


#endif  // _LIBCPP_FSTREAM22
